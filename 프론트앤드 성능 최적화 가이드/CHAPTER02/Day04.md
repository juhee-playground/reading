# DAY 4

## 🔖 오늘 읽은 범위 :  2장 올림픽 통계 서비스 최적화

- 애니메이션 최적화
- 컴포넌트 지연 로딩
- 컴포넌트 사전 로딩
- 이미지 사전 로딩

---

<aside>
    😃 **기억하고 싶은 내용**
</aside>

### 애니메이션 최적화

#### 애니메이션의 원리

여러 장의 이미지를 빠르게 전환하여 우리 눈에 잔상을 남기고 그로 인해 연속된 이미지가 움직이는 것처럼 느껴지게 하는 것.

- 일반적으로 사용하는 주사율 60Hz ⇒ 1초에 60장의 정지된 화면을 빠르게 보여준다는 의미
- 브라우저 역시 최대 60FPS로 1초에 60장의 화면을 새로 그린다.

#### 브라우저 렌더링 과정

주요 렌더링 경로 또는 픽셀 파이프라인이라고 부른다.

<aside>
💡 DOM + CSSOM ⇒ 렌더트리 ⇒ 레이아웃 ⇒ 페인트 ⇒ 컴포지트
</aside>

- DOM + CSSOM
    다운로드한 리소스를 브라우저가 이해할 수 있는 형태로 변환(파싱과정). 
    트리구조로 표현된 DOM을 생성.
    CSSOM 또한 트리구조로 생성.

- 렌더트리    
    DOM + CSSOM 의 결합으로 생성. 화면에 표시되는 각 요소의 레이아웃을 계산하는데 사용.
    ex) display: none; 화면에 표시되지 않는 요소는 렌더트리에 포함되지 않는다.

- 레이아웃
    화면 구성요소의 위치나 크기를 계산하고 해당 위치에 요소를 배치하는 작업을 말한다.

- 페인트
    화면에 배치된 요소에 색을 채워 넣는 작업. 브라우저는 효율적인 작업을 위해 구성요소를 여러개의 레이어로 나눠서 작업.

- 컴포지트
    각 레이어를 합성하는 작업을 합니다(페인트 작업 때 나눠논 레이어를 합치는 작업).

- 리플로우와 리페인트
    화면이 전부 그려진 후 애니메이션의 일부가 변경되는 경우. 주요 렌더링 경로에서 거친 과정을 다시 한 번 실행하면서 새로운 화면을 그리는 것.

  - 리플로우 과정
    DOM + CSSOM ⇒ 렌더트리 ⇒ 레이아웃 ⇒ 페인트 ⇒ 컴포지트
    ⇒ 브라우저 리소스 많이 사용.
  - 리페인트 과정
    DOM + CSSOM ⇒ 렌더트리 ⇒ 페인트 ⇒ 컴포지트

    리플로우나 리페인트를 거치는 과정은 모든 단계를 거치기 때문에 리소스를 꽤 잡아 먹는다.    
    이런 느림을 좀 더 빨리 처리하기 위해 transform, opacity와 같은 속성을 사용하는 방법이 있다.

#### 하드웨어 가속(GPU 가속)

CPU에서 처리해야 할 작업을 GPU에 위임하여 더욱 효율적으로 처리하는 방법.
GPU는 애초에 그래픽 작업을 처리하기 위해 만들어진 것으로 화면을 그릴 때 굉장히 빠르다.
⇒ 분리된 레이어는 레이아웃과 페인트 단계 없이 화면상의 요소의 스타일을 변경할 수 있다.

### 컴포넌트 지연 로딩

- 페이지가 변경되는 시점에 로드.
- 모달 코드 분리.

#### 지연로딩의 단점

초기 로딩속도는 빨라지지만 모달을 띄우는 시점에는 한계가 있다.
클릭 시점과 모달이 뜨는 시점이 크게 차이가 나는 것을 확인 할 수 있다.

2가지 해결법 존재

- 컴포넌트 사전 로딩 타이밍
    마우스가 버튼을 클릭 하기 전 버튼 위에 마우스를 올려 뒀을 때 로딩
- 컴포넌트 마운트 완료 후 사전 로딩
    모달 컴포넌트의 크기가 커서 1초 또는 그 이상일 떄 사용.
    클래스형 컴포넌트 라면 componentDidMount 시점
    함수형 컴포넌트 라면 useEffect 시점

#### 이미지 사전 로딩

사전 로드할 이미지를 useEffect에 넣어줌,

    <aside>
    🤔 **오늘의 파트에 대한 소감**
    </aside>

- 밀리지 말자!!! 밀리면 고생해ㅠㅠ

    <aside>
    🔎 **추가로 알게 된 것 (책 내용 +알파로 궁금한 것, 이해가 가지 않는 것 등)**
    </aside>